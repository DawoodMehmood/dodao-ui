When working with the UI working you might primarily be working with the following things:
1. Adding new components - This follows react and nextjs conventions.
2. Adding new graphql queries - This is when you need to fetch data from the backend and show it on the UI.
3. Adding new graphql mutations - This is when you need to send data to the backend and update the database.

## Adding new queries

Note: Some of the data is fetched from API instead of the graphql. This was done to support nextjs server side rendering.
So check if you need to fetch the new data as API or graphql first.


#### Step 1 - Download the latest graphql schema
The schema file is updated at the API/backend layer and we run `yarn graphql:download` to update the schema file in the UI layer.

When fetching the latest schema file, make sure you have the latest version of the API running as the schema is fetched from
`http://localhost:8000/graphql` url.

#### Step 2 - Declare new query in the graphql file
For this you need a add a .graphql file e.g. `src/graphql/byte/byteCollection.graphql`. In this file you need to add
the new query. For example:
```graphql
fragment ByteCollection on ByteCollection {
  id
  name
  description
  status
  byteIds
  order
  bytes {
    byteId
    name
    content
  }
}

query ByteCollections($spaceId: String!) {
  byteCollections(spaceId: $spaceId) {
    ...ByteCollection
  }
}

query ByteCollection($spaceId: String!, $byteCollectionId: String!) {
  byteCollection(spaceId: $spaceId, byteCollectionId: $byteCollectionId) {
    ...ByteCollection
  }
}

```

These queries map to the schema defined in `src/schema.graphql`. If the queries are not present in the schema then
you will get an error. 

#### Step 3 - Generate graphql files/types/code
Run `yarn graphql:generate` to generate the graphql files/types/code. This will generate the following code:
1. Types - Types corresponding to the data returned by the graphql queries.
2. Hooks - Hooks corresponding to the graphql queries. These hooks can be used to fetch data from the backend.

#### Step 4 - Use the hooks to fetch data
See `src/app/projects/view/[projectId]/[viewType]/page.tsx` for an example of how to use the hooks to fetch data.

Here is the code
```typescript
import {
  SpaceWithIntegrationsFragment,
  useProjectByteCollectionsQuery,
  useProjectByteQuery,
  useProjectBytesQuery,
  useProjectQuery,
} from '@/graphql/generated/generated-types';


const { loading: loadingByteCollections, data: byteCollectionsData } = useProjectByteCollectionsQuery({
    variables: {
      projectId: props.params.projectId,
    },
});

```
The types imported are generated by the graphql code generation step. This makes sure the UI code
is always typed and are using the right fields

## Adding new mutations
#### Step 1 - Download the latest graphql schema
The schema file is updated at the API/backend layer and we run `yarn graphql:download` to update the schema file in the UI layer.

When fetching the latest schema file, make sure you have the latest version of the API running as the schema is fetched from
`http://localhost:8000/graphql` url.

#### Step 2 - Declare new mutation in the graphql file
For this you need a add a .graphql file e.g. `src/graphql/byte/byteCollection.graphql`. In this file you need to add
the new mutation. For example:
```graphql
fragment ByteCollection on ByteCollection {
  id
  name
  description
  status
  byteIds
  order
  bytes {
    byteId
    name
    content
  }
}

mutation CreateByteCollection($input: CreateByteCollectionInput!) {
  createByteCollection(input: $input) {
    ...ByteCollection
  }
}

mutation UpdateByteCollection($input: UpdateByteCollectionInput!) {
  updateByteCollection(input: $input) {
    ...ByteCollection
  }
}

```

#### Step 3 - Generate graphql files/types/code
Run `yarn graphql:generate` to generate the graphql files/types/code. This will generate the following code:
1. Types - Types corresponding to the data to be sent to the backend and also the data returned by the backed in the response.
2. Hooks - Hooks corresponding to the graphql mutations. These hooks can be used to send data to the backend.

```typescript
import {
  SpaceWithIntegrationsFragment,
  useCreateByteCollectionMutation,
  useQueryBytesQuery,
  useUpdateByteCollectionMutation,
} from '@/graphql/generated/generated-types';

const [updateByteCollectionMutation] = useUpdateByteCollectionMutation();

const [createByteCollectionMutation] = useCreateByteCollectionMutation();

async function upsertByteCollectionFn(byteCollection: EditByteCollection, byteCollectionId: string | null) {
  if (!byteCollectionId) {
    await createByteCollectionMutation({
      variables: {
        input: {
          spaceId: props.space.id,
          name: byteCollection.name,
          description: byteCollection.description,
          byteIds: byteCollection.bytes.map((byte) => byte.byteId),
          status: byteCollection.status,
          order: byteCollection.order,
        },
      },
    });
  } else {
    await updateByteCollectionMutation({
      variables: {
        input: {
          byteCollectionId,
          name: byteCollection.name,
          description: byteCollection.description,
          byteIds: byteCollection.bytes.map((byte) => byte.byteId),
          status: byteCollection.status,
          spaceId: props.space.id,
          order: byteCollection.order,
        },
      },
    });
  }
}
```

The types imported are generated by the graphql code generation step. This makes sure the UI code
is always typed and are using the right fields
